#!/usr/local/bin/python3
"""

This script expects a github repo to have the format:
  Repo_Name
      Assignments
          A01
          A02
          A0N
      Lectures
          L01
          L02
          L0N
      Resources
          R01
          R02
          R0N
  It takes the README.md in each of the folders (Assignment,Lectures,Resources) and 
  creates a table that holds links with descriptions to each of the folders within.
  The descriptions are taken from the title at the top of each README.md folders for
  a particular item. If it has a line with "due" in it, it will create a "due date"
  in the table.

  The titles at the top of a README.md should contain the following format:
  # Major title - sub title / description
  #### Due: due_date
"""

from subprocess import call
import sys
import os
from time import gmtime, strftime
import pprint as pp
from tomark import Tomark
import datetime
import time
from rich import print


def hasNumbers(inputString):
    return any(char.isdigit() for char in inputString)


legend = """
### File Legend

| Folder Name | Description |
|:-----------|:-------------|
|xx-**A**xx | This is some kind of an ***Assignment***, where an `assignment` can be anything that isn't big enough to be a full fledged program, and not specific enough to be a homework. |
|xx-**H**xx | This is a ***Homework***. Something pretty specific, usually not requiring a lot of programming. |
|xx-**P**xx | This is a ***Program***. Where it must be compiled, run error free, commented, and correct. |
|xx-**T**xx | This is a ***Test***. Usually when on github, it will start out as a study guide, then get accompanied with a solution after the exam. |
"""

# timestamp of now
now = datetime.datetime.now()

#now = datetime.datetime(2021, 9, 1)


def removeBlankLines(lines):
    copyLines = []
    for line in lines:
        if len(line.strip()) > 0:
            copyLines.append(line)
    return copyLines


def sortMDTable(data):
    """sort markdown table 

    Args:
        data (list): list of assignments

    Returns:
        [type]: [description]
    """
    #pp.pprint(data)
    no_due_date = []
    due_dates = []

    for item in data:
        if type(item['days']) == int and item['days'] < 0:
            no_due_date.append(item)
        else:
            due_dates.append(item)

    for i in range(len(due_dates)):
        smallest = due_dates[i]['Due'][:11]
        loc = i
        for j in range(i, len(due_dates)):
            if hasNumbers(due_dates[j]['Due']
                          [:11]) and due_dates[j]['Due'][:11] < smallest:
                smallest = due_dates[j]['Due'][:11]
                loc = j

        temp = due_dates[i]
        due_dates[i] = due_dates[loc]
        due_dates[loc] = temp

    due_dates.extend(no_due_date)

    # print("")
    # for row in data:
    #     print(row['Due'])
    return due_dates


def alignMarkdownTable(data, alignment):
    """Description:
            This method receives markdown generated by tomark and 
            changes the alignment of each column if so desired.
       Usage:
            data = markdown table
            alignment = list of alignments (or none = Left) for each column
                ['L',None,'R',None,'C']  
    """
    data = data.split("\n")
    columns = data[1].split("|")
    i = 1
    for align in alignment:
        if 'L' in align:
            columns[i] = ':------'
        if 'C' in align:
            columns[i] = ':-----:'
        if 'R' in align:
            columns[i] = '------:'
        i += 1

    columns = '|'.join(columns)
    data[1] = columns
    return '\n'.join(data)


def generateMDTable(data, category):
    """Generate a markdown table with a list of repo files and due dates

    Args:
        data (list): list dictionaries of file information 
        sort_table (bool, optional): Sort on due date or not. Defaults to False.

    Returns:
        [type]: [description]
    """

    # monday of this week
    monday = now - datetime.timedelta(days=now.weekday())

    # sort results table on due date
    if category.lower() == 'assignments':
        data = sortMDTable(data)

    # foreach assignment ...
    for row in data:
        if category.lower() == 'assignments':
            row['Days Left'] = False  # prime days left column for assignments
        else:
            row[''] = ''  # nothing for other categories
        dueDate = row['dueDate']
        parts = row['Filename'].split("/")  # split filename into pieces
        repo = parts[-4]
        category = parts[-3]
        folder = parts[-2]
        days = row['days']

        # build link that will work on github
        link = os.path.join('https://github.com/rugbyprof/', repo,
                            'tree/master', category, folder)

        # remove data not needed in final table
        del row['Filename']
        del row['days']

        # add markdown to `linethrough` past assignments
        for key, val in row.items():
            if days != None and days < 0:
                row[key] = f"~<a href=\"{link}\">{val}</a>~"
            else:
                row[key] = f"***<a href=\"{link}\">{val}</a>***"

        # print debug info
        if dueDate:
            print("diff:", end=": ")
            print(f"Now:{now} dueDate:{dueDate}   Days:{(now-dueDate).days} ")

        if days != None:
            days = (now - dueDate).days * -1
            if days == 0:
                days = 'DUE TODAY!'
            elif days < 0:
                days = '----'
        else:
            days = ''

        #row['Still Available'] = f'<img src="https://cs.msutexas.edu/~griffin/zcloud/zcloud-files/{color}" width="40">'
        if category.lower() == 'assignments':
            row['Days Left'] = days
        else:
            row[''] = ''

    markdown = Tomark.table(data)
    markdown = alignMarkdownTable(markdown, ['L', 'L', 'L', 'L', 'C'])

    return markdown
    # Generate table footer
    # for row in info['rows']:
    #     table += ' | '
    #     table += ' | '.join(row)
    #     table += ' |\n'
    # table += '\n<sup>Last Updated: '+current+'</sup>'
    # print(table)
    # return(table)


def generateReadmes(repo, category, files):
    """""
        ## Assignment 1 - Getting Started
        #### Due: 01-13-2021 (Saturday @ 12:00 p.m.)
        
    Args:
        repo (string): repo folder and path
        category (string): Assignments,Resources,Lectures (folder name)
        files (list): list of README's
    """

    data = []

    for filestuff in files:
        title = None
        description = None
        due = None
        folder = None
        dueDate = None

        parts = filestuff.split("/")
        if len(parts) > 2:
            folder = parts[-2]

        with open(filestuff, 'r') as f:
            lines = f.readlines()

        lines = removeBlankLines(lines)

        if isinstance(lines, list) and len(lines) > 0:
            if '#' in lines[0]:
                line = lines[0].strip()
                line = line.strip("#")
                parts = line.split('-')
                if len(parts) == 2:
                    title = parts[0]
                    description = parts[1]

            if len(lines) > 1:
                if '#' in lines[1]:
                    line = lines[1].strip()
                    due = line.strip("#")
                    if 'due:' in due.lower():
                        due = due[5:]
                        #print(f"due:{due}")

        dt = None
        days = None

        if due == None:
            due = "N/A"
        elif '-' in due:
            parts = due.strip().split(' ')

            if len(parts) > 1:
                #print(parts)
                month, day, year = parts[0].split('-')
                #print(f"dt:{month},{day},{year} ")
                dt = datetime.datetime(year=int(year),
                                       month=int(month),
                                       day=int(day))

                days = (now - dt).days * -1
                # make a timestamp
                dueDate = time.mktime(dt.timetuple())
                #print(days)

        data.append({
            'Folder': folder,
            'Title': title,
            'Description': description,
            'Due': due,
            'Filename': filestuff,
            'days': days,
            'dueDate': dt
        })

    if len(data) == 0:
        table = Tomark.table([{
            'Folder': None,
            'Title': None,
            'Description': None,
            'Due': None,
            'Filename': None,
            'Due': None,
            'Filename': None
        }])
    else:
        table = generateMDTable(data, category)

    table = table.replace('Days Left', 'Days Left<sup>*</sup>')

    #markdown = Tomark.table(data)

    write_readme(repo, table, category)


def write_readme(repo, table, category):

    path = os.path.join(repo, category, 'README.md')

    with open(path, 'w') as f:
        f.write(f"## {category}\n\n")

        f.write(table)

        #f.write("\nItems without a due date or if the due date is ~~lined through~~, consider it not assigned.")

        #f.write(legend)

        current = strftime("%Y-%m-%d (%a @ %H:%M)")
        f.write('\n<sup>Last Updated: ' + current + '</sup> \n\n')
        f.write(
            "<sup>***Days Left is only accurate if the `Last Updated` date is the same as todays date. Otherwise, use the due date!***</sup> "
        )


def collect_files(repo):
    folders = ['Assignments', 'Lectures', 'Resources']
    files = {'Assignments': [], 'Lectures': [], 'Resources': []}
    for sub in folders:
        for f in os.listdir(os.path.join(repo, sub)):
            if os.path.isdir(os.path.join(repo, sub, f)):
                if not os.path.isfile(os.path.join(repo, sub, f, 'README.md')):
                    with open(os.path.join(repo, sub, f, 'README.md'),
                              "w") as rdme:
                        rdme.write("## Placeholder Readme - No Description")
                files[sub].append(os.path.join(repo, sub, f, 'README.md'))
        files[sub].sort()
    return files


def filter_repos(workingFolder):
    repos = []

    # if there is a .git folder in this directory, then handle only it
    if os.path.isdir(os.path.join(workingFolder, '.git')):
        return [workingFolder]

    # otherwise get all the folders in this directory that are repos
    all = os.listdir(workingFolder)

    for f in all:
        if os.path.isdir(os.path.join(workingFolder, f, '.git')):
            repos.append(f)

    return repos


def printUsage():
    print('Usage: ??')
    sys.exit(0)


def mykwargs(argv):
    '''
    Processes argv list into plain args and kwargs.
    Just easier than using a library like argparse for small things.
    Example:
        python file.py arg1 arg2 arg3=val1 arg4=val2 -arg5 -arg6 --arg7
        Would create:
            args[arg1, arg2, -arg5, -arg6, --arg7]
            kargs{arg3 : val1, arg4 : val2}
        
        Params with dashes (flags) can now be processed seperately

    Shortfalls: 
        spaces between k=v would result in bad params
    Returns:
        tuple  (args,kargs)
    '''
    args = []
    kargs = {}

    for arg in argv:
        if '=' in arg:
            key, val = arg.split('=')
            kargs[key] = val
        else:
            args.append(arg)
    return args, kargs


if __name__ == "__main__":

    argv = sys.argv[1:]

    args, kargs = mykwargs(argv)

    if kargs:
        d = kargs.get['d', None]
        ddir = kargs.get['dir', None]
        directory = kargs.get['directory', None]
        path = kargs.get['path', None]

        if d:
            folder = d
        elif ddir:
            folder = ddir
        elif directory:
            folder = directory
        elif path:
            folder = path

    elif len(args) > 0:
        folder = args[0]
    else:
        # Get the directory of the folder your in.
        folder = os.getcwd()

    repos = filter_repos(folder)

    # if len(repos) > 1:
    #     print("Update the following repos?:")
    #     ans = input("('Y' or choose repo with index #) : ")

    #     if ans.lower() != 'y' and len(ans) > 0:
    #         if int(ans) in range(len(repos)):
    #             repos = [repos[int(ans)]]

    #
    for repo in repos:
        name = os.path.basename(repo)
        print(f"Generating Readmees for: {name}")
        files_dict = collect_files(repo)
        for category, files in files_dict.items():
            print(f"Updating: {category}")
            generateReadmes(repo, category, files)
